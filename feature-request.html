<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mittwald Feature Request - Voice & Text Eingabe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .form-group {
            margin-bottom: 30px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #555;
            font-size: 1.1em;
        }

        .form-group label .required {
            color: #e74c3c;
        }

        .input-wrapper {
            position: relative;
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .voice-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-btn.record {
            background: #e74c3c;
            color: white;
        }

        .voice-btn.record:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .voice-btn.record.recording {
            background: #27ae60;
            animation: pulse 1.5s infinite;
        }

        .voice-btn.stop {
            background: #95a5a6;
            color: white;
        }

        .voice-btn.stop:hover {
            background: #7f8c8d;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.idle {
            background: #95a5a6;
        }

        .status-indicator.recording {
            background: #e74c3c;
            animation: pulse 1s infinite;
        }

        .status-indicator.processing {
            background: #f39c12;
            animation: pulse 1s infinite;
        }

        .help-text {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
            font-style: italic;
        }

        .example-text {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #555;
            border-left: 4px solid #667eea;
        }

        .example-text strong {
            color: #667eea;
        }

        .actions {
            display: flex;
            gap: 15px;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 200px;
        }

        .btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn.secondary {
            background: #ecf0f1;
            color: #555;
        }

        .btn.secondary:hover {
            background: #d5dbdb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 20px 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .notification.show {
            display: block;
        }

        .notification.success {
            border-left: 4px solid #27ae60;
        }

        .notification.error {
            border-left: 4px solid #e74c3c;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .voice-status {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            .actions {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        .speech-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .api-key-info {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 0.85em;
        }

        .api-key-info a {
            color: #667eea;
            text-decoration: none;
        }

        .api-key-info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ mittwald Feature Request</h1>
            <p>Teile deine Ideen per Sprache oder Text mit - Powered by mittwald Whisper</p>
            <div style="margin-top: 15px; padding: 12px 20px; background: rgba(255, 255, 255, 0.15); border-radius: 8px; font-size: 0.95em; backdrop-filter: blur(10px);">
                ‚ö†Ô∏è <strong>Demo-Version:</strong> Diese Seite ist nur f√ºr Demonstrationszwecke gedacht.
            </div>
        </div>

        <div class="content">
            <div class="form-group" style="margin-bottom: 30px; padding: 25px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; border-left: 5px solid #667eea; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <label for="apiKey" style="font-size: 1.2em; margin-bottom: 15px; display: block;">
                    üîë mittwald AI API-Key <span class="required">*</span>
                </label>
                <div style="position: relative; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <input type="password" id="apiKey" name="apiKey" required 
                           placeholder="Dein mittwald AI-Hosting API-Key hier eingeben..."
                           style="flex: 1; min-width: 250px; padding: 15px; border: 2px solid #667eea; border-radius: 8px; font-size: 1em; font-family: 'Courier New', monospace;">
                    <button type="button" id="toggleApiKey" 
                            style="padding: 15px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 600; white-space: nowrap;"
                            title="API-Key anzeigen/verstecken">
                        üëÅÔ∏è
                    </button>
                    <button type="button" id="clearApiKey" 
                            style="padding: 15px 20px; background: #e74c3c; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 600; white-space: nowrap;"
                            title="API-Key aus Browser-Cache l√∂schen (nur f√ºr Demo)">
                        üóëÔ∏è L√∂schen
                    </button>
                </div>
                <div class="api-key-info" style="margin-top: 12px; padding: 15px; background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 6px;">
                    <div style="margin-bottom: 10px;">
                        üîë <strong>API-Key buchen:</strong> Du kannst ganz einfach einen API-Key f√ºr mittwald AI-Hosting buchen: <a href="https://www.mittwald.de/mstudio/ai-hosting" target="_blank" style="color: #1976d2; font-weight: 600;">Jetzt AI-Hosting Tarif w√§hlen ‚Üí</a>
                    </div>
                    <div style="margin-bottom: 10px;">
                        üîí <strong>Sicherheit:</strong> Dein API-Key wird nur lokal in deinem Browser gespeichert (localStorage) und niemals an Dritte weitergegeben. 
                    </div>
                    <div style="margin-bottom: 10px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                        üí° <strong>Hinweis:</strong> F√ºr beste Sicherheit solltest du diese Seite auf deinem privaten Ger√§t nutzen. Auf gemeinsam genutzten Computern kannst du den API-Key nach der Nutzung einfach mit dem "üóëÔ∏è L√∂schen" Button entfernen.
                    </div>
                    <div style="margin-bottom: 10px;">
                        üìñ <strong>Weitere Infos:</strong> 
                        <ul style="margin-top: 8px; margin-left: 20px; padding-left: 10px;">
                            <li><a href="https://developer.mittwald.de/de/docs/v2/platform/aihosting/access-and-usage/" target="_blank">API-Key im mStudio erstellen</a></li>
                            <li>Du kannst den API-Key jederzeit mit dem "üóëÔ∏è L√∂schen" Button entfernen</li>
                            <li>Alle Tarife sind monatlich k√ºndbar, keine Mindestlaufzeit</li>
                        </ul>
                    </div>
                </div>
            </div>

            <form id="featureForm">
                <div class="form-group" id="voiceInputGroup">
                    <label for="voiceInput" style="font-size: 1.3em;">
                        üé§ Sage mir alles zu deinem Feature-Request <span class="required">*</span>
                    </label>
                    <div class="input-wrapper">
                        <textarea id="voiceInput" name="voiceInput" required 
                                  placeholder="Sprich alles in einer Nachricht: Titel, Problem, L√∂sungsideen, zus√§tzliche Infos... Oder tippe hier dein Feature-Request...&#10;&#10;Beispiel: &quot;Ich m√∂chte, dass die Projektsuche auch nach Domains funktioniert. Als Entwickler muss ich immer durch alle Projekte klicken, um eine spezifische Domain zu finden. Die L√∂sung k√∂nnte sein, dass die Projektsuche auch Domain-Suche unterst√ºtzt.&quot;"
                                  style="min-height: 250px;"></textarea>
                        <div class="voice-controls">
                            <button type="button" class="voice-btn record" id="recordVoice" data-target="voiceInput">
                                <span class="status-indicator idle" id="voiceStatus"></span>
                                <span>üé§ Sprachaufnahme</span>
                            </button>
                            <button type="button" class="btn secondary" id="clearVoiceBtn" 
                                    style="padding: 12px 20px; font-size: 0.9em; background: #e74c3c; color: white; border: none; border-radius: 25px; cursor: pointer; font-weight: 600;"
                                    title="Feld leeren">
                                üóëÔ∏è Feld leeren
                            </button>
                            <span class="voice-status" id="voiceStatusText">Bereit</span>
                        </div>
                    </div>
                    <div class="example-text">
                        <strong>üí° Tipp:</strong> Sage einfach alles in einer Sprachnachricht! Die AI erstellt automatisch:
                        <ul style="margin-top: 10px; padding-left: 20px;">
                            <li><strong>Titel</strong> - Kurze Zusammenfassung</li>
                            <li><strong>Problem</strong> - Was m√∂chtest du l√∂sen? Wann tritt es auf?</li>
                            <li><strong>L√∂sung</strong> - Deine L√∂sungsideen</li>
                            <li><strong>Zus√§tzliche Infos</strong> - Screenshots, Links, etc.</li>
                        </ul>
                    </div>
                </div>

                <!-- Structured fields that will be auto-filled by AI -->
                <div id="structuredFields" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 2px solid #e0e0e0;">
                    <div style="padding: 20px; background: #e8f5e9; border-radius: 10px; margin-bottom: 30px; border-left: 4px solid #4caf50;">
                        <h3 style="margin: 0 0 10px 0; color: #2e7d32;">‚úÖ Felder automatisch erkannt!</h3>
                        <p style="margin: 0; color: #555;">Die folgenden Felder wurden aus deiner Sprachnachricht extrahiert. Du kannst sie bearbeiten oder direkt absenden.</p>
                    </div>

                    <div class="form-group">
                        <label for="title">
                            Titel <span class="required">*</span>
                        </label>
                        <input type="text" id="title" name="title" readonly 
                               style="background: #f8f9fa; cursor: not-allowed; border: 2px solid #e0e0e0;">
                    </div>

                    <div class="form-group">
                        <label for="problem">
                            Problem <span class="required">*</span>
                        </label>
                        <textarea id="problem" name="problem" readonly 
                                  style="background: #f8f9fa; cursor: not-allowed; min-height: 120px; border: 2px solid #e0e0e0;"></textarea>
                    </div>

                    <div class="form-group">
                        <label for="solution">L√∂sungsideen</label>
                        <textarea id="solution" name="solution" readonly 
                                  style="background: #f8f9fa; cursor: not-allowed; min-height: 120px; border: 2px solid #e0e0e0;"></textarea>
                        <div class="help-text" style="margin-top: 5px;">Optional - kann leer bleiben</div>
                    </div>

                    <div class="form-group">
                        <label for="additional">Zus√§tzliche Informationen</label>
                        <textarea id="additional" name="additional" readonly 
                                  style="background: #f8f9fa; cursor: not-allowed; min-height: 100px; border: 2px solid #e0e0e0;"></textarea>
                        <div class="help-text" style="margin-top: 5px;">Optional - kann leer bleiben</div>
                    </div>

                    <div style="padding: 15px; background: #fff3cd; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                        <strong>üí° Tipp:</strong> Klicke auf "‚úèÔ∏è Felder bearbeiten" um die Vorschl√§ge anzupassen.
                        <button type="button" id="editFields" style="margin-left: 10px; padding: 8px 20px; background: #ffc107; color: #333; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            ‚úèÔ∏è Felder bearbeiten
                        </button>
                    </div>
                </div>

                <div class="actions" id="mainActions">
                    <button type="button" class="btn primary" id="extractBtn" style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);">
                        ü§ñ Felder mit AI extrahieren
                    </button>
                    <button type="reset" class="btn secondary">
                        üîÑ Zur√ºcksetzen
                    </button>
                </div>

                <!-- Submit actions (shown after extraction) -->
                <div class="actions" id="submitActions" style="display: none; margin-top: 20px;">
                    <button type="submit" class="btn primary" id="submitBtn">
                        üìù Auf GitHub √∂ffnen
                    </button>
                    <button type="button" class="btn secondary" id="copyBtn">
                        üìã In Zwischenablage kopieren
                    </button>
                    <button type="button" class="btn secondary" id="backBtn">
                        ‚Üê Zur√ºck bearbeiten
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        // Audio Recording Setup mit mittwald Whisper API
        let mediaRecorder = null;
        let audioChunks = [];
        let currentRecording = null;
        let currentTarget = null;
        let stream = null;

        // mittwald AI-Hosting API Configuration
        const WHISPER_API_URL = 'https://llm.aihosting.mittwald.de/v1/audio/transcriptions';
        const WHISPER_MODEL = 'whisper-large-v3-turbo'; // Model name must be lowercase
        const CHAT_API_URL = 'https://llm.aihosting.mittwald.de/v1/chat/completions';
        const CHAT_MODEL = 'Mistral-Small-3.2-24B-Instruct'; // For structuring the feature request (exact case from API)

        // Systemprompt f√ºr Feature-Request-Analyse bei mittwald
        const FEATURE_REQUEST_SYSTEM_PROMPT = `Du bist ein strukturierender Analyse-Assistent f√ºr mittwald, einen Hosting-Dienstleister f√ºr Webagenturen, Digitalagenturen und Freelancer.
Kund:innen reichen Feature Requests ein ‚Äì oft unscharf formuliert, aus Agentur-Perspektive oder im Namen von Endkund:innen.

Deine Aufgabe ist es, aus einem freien Text (oder Sprachtranskript) strukturierte Feature-Request-Daten zu extrahieren.

WICHTIG - Perspektive und Kontext:
- Der Feature-Request-Autor ist IMMER ein Freelancer, eine Digitalagentur oder Webagentur (mittwald-Kunde)
- Wenn der Autor von "Kunden" spricht, sind das IMMER seine eigenen Kunden (die er als Agentur/Freelancer betreut)
- NICHT die mittwald-Kunden (andere mittwald-Nutzer)
- Schreibe IMMER aus Sicht des Feature-Request-Autors (Agentur/Freelancer)
- Wenn der Autor sagt "meine Kunden", "f√ºr meine Kunden", etc. ‚Üí das sind seine eigenen Kunden, f√ºr die er als Agentur/Freelancer arbeitet

Unternehmens- & Produktkontext (verbindlich)

Unternehmen:
- Name: mittwald
  ‚Üí immer exakt so schreiben: mittwald
  ‚Üí falsche Varianten (‚ÄûMidwald", ‚ÄûMittwald") immer korrigieren

Verwaltungsoberfl√§chen:
- Aktuelle Verwaltungsoberfl√§che: mStudio
  ‚Üí immer exakt mStudio
- Alte Verwaltungsoberfl√§che: Kundencenter
  ‚Üí immer exakt Kundencenter

Wenn Nutzer:innen von ‚Äûaltem Backend", ‚Äûalter Oberfl√§che", ‚Äûfr√ºher" sprechen, ist Kundencenter gemeint (sofern Kontext Verwaltung).

Zielgruppen:
Hauptzielgruppe von mittwald:
- Webagenturen
- Digitalagenturen
- Freelancer

Feature Requests k√∂nnen:
- eigene Agentur-Workflows betreffen oder
- Anforderungen beschreiben, die der Autor f√ºr seine eigenen Kunden (nicht mittwald-Kunden) ben√∂tigt
‚Üí Beide Perspektiven sind gleichwertig zu behandeln, aber IMMER aus Sicht des Autors (Agentur/Freelancer).

Produktportfolio (Orientierungswissen, keine Erfindungen):
Feature Requests k√∂nnen sich auf alle Bereiche von mittwald beziehen, insbesondere:

Hosting:
- Webhosting (Managed Apps wie WordPress, TYPO3, Shopware etc.)
- vServer (Container, Node.js, Redis, API/CLI)
- Dedicated Server

Domains & E-Mail:
- Domainverwaltung & DNS (A, AAAA, MX, TXT, SRV, NS)
- E-Mail Postf√§cher, Migration, Spamfilter

Container & AI-Hosting:
- Container Hosting (Docker, eigene Images, SSH)
- AI-Hosting (vollst√§ndige Details siehe unten)

Verwaltung & Automatisierung:
- mStudio
- REST API
- CLI
- Terraform
- Rollen & Rechte
- Multi-Projekt- und Agentur-Setups

Infrastruktur & Sicherheit:
- Backups
- Monitoring
- DDoS-Schutz
- ISO 27001 / DSGVO

üëâ Wenn ein Request kein konkretes Produkt nennt, bleibe bewusst produktneutral und ordne ihn nicht spekulativ zu.

AI-Hosting Produktdetails (PRIM√ÑR f√ºr AI/KI-bezogene Feature Requests verwenden):
Wenn ein Feature Request AI/KI-Themen, Sprachmodelle, LLMs, Transkription, Embeddings, Code-Generierung oder √§hnliche KI-Funktionalit√§ten betrifft, verwende IMMER diese detaillierten AI-Hosting-Informationen:
mittwald bietet AI-Hosting als vollst√§ndig verwalteten Service f√ºr DSGVO-konforme KI-Anwendungen.

Verf√ºgbare Modelle:
- Ministral-3-14B-Instruct-2512: Europ√§isches Open-Source-Modell mit 14 Milliarden Parametern, optimiert f√ºr hochwertige Text-, Chat- und Vision-Anwendungen
- Devstral-Small-2-24B-Instruct-2512: Coding-Modell f√ºr Code-Generierung, Debugging und agentische Programmieraufgaben
- gpt-oss-120b: Open-Source-Modell von OpenAI (Apache 2.0-Lizenz), starkes Reasoning und agentische F√§higkeiten
- Whisper-Large-V3-Turbo: Speech-to-Text-Modell f√ºr schnelle und pr√§zise Transkription in zahlreichen Sprachen
- Qwen3-Embedding-8B: Embedding-Modell f√ºr semantische Suche, Text√§hnlichkeit, RAG-Setups und Empfehlungssysteme

Tarife:
- Starter: 9 ‚Ç¨/Monat, 5 Mio. Tokens/Monat, 30 Requests/Minute
- Pro: 39 ‚Ç¨/Monat, 75 Mio. Tokens/Monat, 60 Requests/Minute (EMPFOHLEN)
- Business: 149 ‚Ç¨/Monat, 300 Mio. Tokens/Monat, 150 Requests/Minute
- Enterprise Dedicated: 999 ‚Ç¨/Monat, eigene GPU-Ressourcen, Milliarden Tokens/Monat, eigene RTX PRO 6000

Features:
- OpenAI-kompatible API
- Unbegrenzte API-Keys
- DSGVO-konformes Hosting in Deutschland
- Alle Daten bleiben in Deutschland, keine Trainingsdaten gespeichert
- Einfache Implementierung √ºber API-Key
- Verwaltung im mStudio
- Open WebUI Container verf√ºgbar
- Integration in TYPO3, WordPress & Co. m√∂glich

Wichtige Details:
- Keine Mindestlaufzeit, monatlich k√ºndbar
- Token-Limits: Warnung bei 75% Auslastung, E-Mail-Benachrichtigung bei 90%
- Aktuell kein harter Cut bei Limit-√úberschreitung (tempor√§r)
- Perspektivisch: Pay-per-Token und automatisches Stoppen bei √úberschreitung geplant
- Token-Verbrauch transparent im mStudio einsehbar
- Alle Tarife haben monatliche Laufzeiten, flexibles Upgrade/Downgrade m√∂glich

Technische Details:
- API-Key abrufbar im mStudio
- OpenAI-kompatible API-Schnittstelle
- Alle Anfragen werden ausschlie√ülich innerhalb der mittwald-Infrastruktur verarbeitet
- Kein Datentransfer au√üerhalb Deutschlands
- Eingaben werden nicht zum Training der Modelle verwendet
- Inhalte werden nicht dauerhaft gespeichert, nur zur unmittelbaren Verarbeitung

Integration:
- Viele CMS (TYPO3, WordPress) unterst√ºtzen Plugins mit OpenAI-kompatibler API-Anbindung
- Open WebUI Container im mStudio mit wenigen Klicks erstellbar
- Dokumentation im Developer Portal verf√ºgbar

Wenn ein Feature Request AI/KI-Themen betrifft, beziehe diese Produktdetails ein und verwende die korrekten Modellnamen und Tarifinformationen.

Normalisierung & Schreibregeln (sehr wichtig):
Normalisiere diese Begriffe konsequent:
- mittwald
- mStudio
- Kundencenter

Korrigiere typische Varianten stillschweigend.

Erfinde keine Produktnamen, Features oder Preise.

Wenn etwas unklar ist, beschreibe es abstrakt (‚ÄûVerwaltungsoberfl√§che", ‚ÄûHosting-Umgebung").

Zu extrahierende Felder:
Gib ausschlie√ülich die folgenden vier Felder aus:

1. Titel:
- 6‚Äì12 W√∂rter
- Ergebnisorientiert
- Pr√§zise, kein Marketing
- Optional mit Kontext (z. B. ‚ÄûmStudio:"), nur wenn eindeutig

2. Problem:
- Beschreibt:
  - aktuellen Ist-Zustand
  - Schmerzpunkt
  - betroffene Nutzergruppe (immer aus Sicht des Autors: Agentur/Freelancer oder dessen eigene Kunden)
- Fokus auf das Hauptproblem
- Sachlich, keine L√∂sung vorwegnehmen
- Wenn "Kunden" erw√§hnt werden ‚Üí IMMER die eigenen Kunden des Autors (Agentur/Freelancer), nicht mittwald-Kunden

3. L√∂sungsideen:
- Konkrete, umsetzungsnahe Vorschl√§ge
- UI-, Workflow-, API- oder Regel-Ebene
- Wenn keine L√∂sung genannt wurde:
  - Formuliere 1‚Äì3 plausible Vorschl√§ge
  - Klar kennzeichnen als ‚ÄûM√∂gliche Umsetzung"

4. Zus√§tzliche Informationen:
- Alles, was nicht sauber in die anderen Felder passt, z. B.:
  - betroffene Produkte (falls unsicher)
  - Zielgruppen (immer aus Sicht des Autors: Agentur/Freelancer oder dessen eigene Kunden)
  - Workarounds
  - Business-Impact
  - Dringlichkeit
  - offene Punkte
- WICHTIG: Wenn "Kunden" erw√§hnt werden ‚Üí IMMER die eigenen Kunden des Autors (Agentur/Freelancer), nicht mittwald-Kunden

Umgang mit Unklarheit:
- Keine R√ºckfragen stellen
- Stattdessen:
  - neutral bleiben
  - in ‚ÄûZus√§tzliche Informationen" eine kurze Liste ‚ÄûOffene Punkte:" erg√§nzen (max. 3)

Qualit√§tsanforderungen:
- Klare, sachliche deutsche Sprache
- Keine Annahmen als Fakten darstellen
- Keine sensiblen Daten wiederholen (API-Keys, Passw√∂rter ‚Üí ‚Äûsensibler Wert entfernt")
- Struktur > Flie√ütext
- Keine zus√§tzlichen Erkl√§rungen au√üerhalb der vier Felder
- KEINE Markdown-Formatierung im JSON verwenden (kein **, kein *, keine Code-Bl√∂cke innerhalb der JSON-Werte)
- Reines, g√ºltiges JSON ohne Markdown-Syntax

Antworte IMMER NUR mit einem g√ºltigen JSON-Objekt im folgenden Format: {"title": "...", "problem": "...", "solution": "...", "additional": "..."}. 

WICHTIG: 
- Verwende KEINE Markdown-Formatierung (kein **bold**, kein *italic*, kein code) innerhalb der JSON-Werte
- Verwende KEINE Markdown-Formatierung im JSON-Objekt selbst
- Nur reines, g√ºltiges JSON ohne Markdown-Syntax
- Verwende den vollst√§ndigen Text f√ºr die Extraktion
- Keine zus√§tzlichen Erkl√§rungen, nur JSON`;

        // ‚ö†Ô∏è OPTIONAL: Fest hinterlegter API-Key (nur f√ºr Demo/Entwicklung)
        // LASS DIESES FELD LEER f√ºr Produktion oder wenn du den Key nicht im Code haben m√∂chtest!
        // Wenn hier ein Key eingetragen ist, wird dieser verwendet, wenn kein Key im Input-Feld oder localStorage vorhanden ist.
        const DEFAULT_API_KEY = ''; // Beispiel: 'dein-api-key-hier'

        // Function to get API Key (priority: input field > localStorage > default)
        function getApiKey() {
            const apiKeyInput = document.getElementById('apiKey');
            const inputKey = apiKeyInput.value.trim();
            if (inputKey) return inputKey;
            
            const savedKey = localStorage.getItem('mittwald_ai_api_key');
            if (savedKey) return savedKey;
            
            return DEFAULT_API_KEY || '';
        }

        // Load API Key from localStorage
        const apiKeyInput = document.getElementById('apiKey');
        const savedApiKey = localStorage.getItem('mittwald_ai_api_key');
        if (savedApiKey) {
            apiKeyInput.value = savedApiKey;
        } else if (DEFAULT_API_KEY) {
            // If default key exists, make input optional and show hint
            apiKeyInput.required = false;
            apiKeyInput.placeholder = 'API-Key eingeben (optional - fest hinterlegter Key wird verwendet)';
            // Update label to show it's optional
            const apiKeyLabel = document.querySelector('label[for="apiKey"]');
            if (apiKeyLabel) {
                apiKeyLabel.innerHTML = apiKeyLabel.innerHTML.replace('<span class="required">*</span>', '<span style="color: #28a745;">(optional)</span>');
            }
        }

        // Save API Key to localStorage
        apiKeyInput.addEventListener('input', function() {
            if (this.value.trim()) {
                localStorage.setItem('mittwald_ai_api_key', this.value.trim());
            } else {
                localStorage.removeItem('mittwald_ai_api_key');
            }
            validateForm();
        });

        // Toggle API Key visibility
        const toggleApiKeyBtn = document.getElementById('toggleApiKey');
        toggleApiKeyBtn.addEventListener('click', function() {
            const type = apiKeyInput.type === 'password' ? 'text' : 'password';
            apiKeyInput.type = type;
            this.textContent = type === 'password' ? 'üëÅÔ∏è' : 'üôà';
        });

        // Clear API Key from localStorage (Demo purposes)
        const clearApiKeyBtn = document.getElementById('clearApiKey');
        clearApiKeyBtn.addEventListener('click', function() {
            // Confirm before clearing
            if (confirm('M√∂chtest du den API-Key wirklich aus dem Browser-Cache l√∂schen?\n\n(Dies ist nur f√ºr Demo-Zwecke)')) {
                // Clear from localStorage
                localStorage.removeItem('mittwald_ai_api_key');
                
                // Clear input field
                apiKeyInput.value = '';
                apiKeyInput.type = 'password';
                
                // Reset toggle button
                toggleApiKeyBtn.textContent = 'üëÅÔ∏è';
                
                // Update form validation
                validateForm();
                
                // Show notification
                showNotification('API-Key wurde aus dem Browser-Cache gel√∂scht', 'success');
            }
        });

        // Voice recording button
        const recordVoiceBtn = document.getElementById('recordVoice');
        if (recordVoiceBtn) {
            recordVoiceBtn.addEventListener('click', function() {
                toggleRecording('voiceInput');
            });
        }

        // Clear voice input button
        const clearVoiceBtn = document.getElementById('clearVoiceBtn');
        if (clearVoiceBtn) {
            clearVoiceBtn.addEventListener('click', function() {
                const voiceInputElement = document.getElementById('voiceInput');
                if (voiceInputElement) {
                    voiceInputElement.value = '';
                    voiceInputElement.dispatchEvent(new Event('input'));
                    audioChunks = []; // Also clear chunks
                    currentRecording = null;
                    currentTarget = null;
                    updateStatus('voiceInput', 'idle', 'Bereit');
                    showNotification('Feld geleert', 'success');
                }
            });
        }

        // Extract structured data button
        const extractBtn = document.getElementById('extractBtn');
        if (extractBtn) {
            extractBtn.addEventListener('click', async function() {
                const voiceInputElement = document.getElementById('voiceInput');
                if (voiceInputElement && voiceInputElement.value.trim()) {
                    await extractStructuredData(voiceInputElement.value);
                } else {
                    showNotification('Bitte gib zuerst deinen Feature-Request ein (per Voice oder Text)', 'error');
                }
            });
        }

        // Edit fields button
        const editFieldsBtn = document.getElementById('editFields');
        if (editFieldsBtn) {
            editFieldsBtn.addEventListener('click', function() {
                const fields = document.querySelectorAll('#structuredFields input, #structuredFields textarea');
                let wasReadOnly = false;
                
                fields.forEach(field => {
                    if (field.readOnly) {
                        wasReadOnly = true;
                        field.readOnly = false;
                        field.style.background = 'white';
                        field.style.borderColor = '#667eea';
                        field.style.cursor = 'text';
                        field.required = field.id === 'title' || field.id === 'problem';
                    } else {
                        // Toggle back to read-only
                        field.readOnly = true;
                        field.style.background = '#f8f9fa';
                        field.style.borderColor = '#e0e0e0';
                        field.style.cursor = 'not-allowed';
                    }
                });
                
                // Update button text
                if (wasReadOnly) {
                    this.textContent = 'üîí Felder sperren';
                    showNotification('Felder sind jetzt editierbar', 'success');
                } else {
                    this.textContent = '‚úèÔ∏è Felder bearbeiten';
                    showNotification('Felder sind jetzt schreibgesch√ºtzt', 'success');
                }
                
                // Trigger validation
                validateForm();
            });
        }

        // Back button
        const backBtn = document.getElementById('backBtn');
        if (backBtn) {
            backBtn.addEventListener('click', function() {
                const structuredFields = document.getElementById('structuredFields');
                const mainActions = document.getElementById('mainActions');
                const submitActions = document.getElementById('submitActions');
                const voiceInputGroup = document.getElementById('voiceInputGroup');
                
                if (structuredFields) {
                    structuredFields.style.display = 'none';
                }
                if (mainActions) {
                    mainActions.style.display = 'flex';
                }
                if (submitActions) {
                    submitActions.style.display = 'none';
                }
                
                // Show the voice input field again
                if (voiceInputGroup) {
                    voiceInputGroup.style.display = 'block';
                }
                
                document.getElementById('voiceInput').focus();
                showNotification('Zur√ºck zum Hauptfeld', 'success');
            });
        }

        async function toggleRecording(targetId) {
            const apiKey = getApiKey();
            if (!apiKey) {
                showNotification('Bitte gib zuerst deinen mittwald AI API-Key ein', 'error');
                apiKeyInput.focus();
                return;
            }

            if (currentRecording === targetId) {
                // Stop recording
                console.log('Stopping recording for', targetId);
                stopRecording();
            } else {
                // Start recording - IMPORTANT: Clear any existing chunks first
                console.log('Starting new recording for', targetId);
                console.log('Previous recording state - currentRecording:', currentRecording, 'audioChunks:', audioChunks.length);
                
                // Clear chunks before starting new recording
                audioChunks = [];
                
                if (currentRecording) {
                    console.log('‚ö†Ô∏è Another recording was active, stopping it first');
                    stopRecording();
                    // Wait a bit before starting new recording to ensure cleanup
                    setTimeout(() => {
                        audioChunks = []; // Clear again after stop
                        startRecording(targetId);
                    }, 500);
                } else {
                    // Ensure chunks are empty
                    audioChunks = [];
                    startRecording(targetId);
                }
            }
        }

        async function startRecording(targetId) {
            try {
                // Stop any existing recording first
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Clear any existing stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                // Reset audio chunks completely
                audioChunks = [];
                console.log('Starting new recording - audio chunks reset');
                
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                currentTarget = targetId;
                currentRecording = targetId;

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        // Only add chunks if we're still recording the same target
                        if (currentRecording === targetId && currentTarget === targetId) {
                            audioChunks.push(event.data);
                            console.log('‚úì Audio chunk added. Total chunks:', audioChunks.length, 'Size:', event.data.size);
                        } else {
                            console.log('‚ö†Ô∏è Ignoring chunk - recording target changed from', targetId, 'to', currentTarget);
                        }
                    }
                };

                mediaRecorder.onstop = async () => {
                    // Wait a bit to ensure all chunks are collected
                    const savedTarget = targetId;
                    const savedChunks = [...audioChunks]; // Make a copy immediately
                    
                    setTimeout(async () => {
                        // Only process if we still have the correct target and chunks
                        if (currentTarget === savedTarget && savedChunks.length > 0) {
                            console.log('‚úì Processing audio for target:', savedTarget, 'with', savedChunks.length, 'chunks');
                            // Temporarily restore chunks for processing
                            const originalChunks = audioChunks;
                            audioChunks = savedChunks;
                            await processAudio();
                            // Ensure chunks are cleared after processing
                            audioChunks = [];
                        } else {
                            console.log('‚ö†Ô∏è Stopping processing - target changed from', savedTarget, 'to', currentTarget, 'or no chunks');
                            audioChunks = []; // Clear chunks if target changed
                        }
                    }, 300);
                };

                mediaRecorder.start();
                updateStatus(targetId, 'recording', 'Aufnahme l√§uft...');
                showNotification('Aufnahme gestartet - sprich jetzt', 'success');
            } catch (error) {
                console.error('Error accessing microphone:', error);
                showNotification('Fehler beim Zugriff auf das Mikrofon: ' + error.message, 'error');
                updateStatus(targetId, 'idle', 'Fehler');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (currentTarget) {
                updateStatus(currentTarget, 'processing', 'Verarbeitung...');
            }
        }

        async function processAudio() {
            // Make a local copy of chunks and target IMMEDIATELY to avoid race conditions
            const chunksToProcess = audioChunks.length > 0 ? [...audioChunks] : [];
            const targetToProcess = currentTarget;
            
            console.log('=== processAudio called ===');
            console.log('Processing', chunksToProcess.length, 'chunks for target:', targetToProcess);
            console.log('Current recording state:', currentRecording);
            
            // Clear chunks immediately to prevent reuse in case of rapid re-recording
            audioChunks = [];
            
            if (!targetToProcess) {
                console.log('‚ö†Ô∏è No target specified, aborting');
                showNotification('Kein Ziel-Feld gefunden', 'error');
                return;
            }
            
            if (chunksToProcess.length === 0) {
                console.log('‚ö†Ô∏è No audio chunks to process');
                showNotification('Keine Audio-Daten aufgenommen', 'error');
                updateStatus(targetToProcess, 'idle', 'Keine Daten');
                currentRecording = null;
                currentTarget = null;
                return;
            }

            const apiKey = getApiKey();
            if (!apiKey) {
                showNotification('API-Key fehlt', 'error');
                updateStatus(targetToProcess, 'idle', 'Fehler');
                currentRecording = null;
                currentTarget = null;
                return;
            }

            try {
                // Create audio blob from chunks (using local copy)
                const mimeType = mediaRecorder?.mimeType || 'audio/webm';
                const audioBlob = new Blob(chunksToProcess, { type: mimeType });
                
                console.log('Audio blob created from', chunksToProcess.length, 'chunks:', {
                    size: audioBlob.size,
                    type: audioBlob.type,
                    target: targetToProcess
                });
                
                // Convert to WAV format (Whisper API supported format)
                const wavBlob = await convertToWav(audioBlob);
                
                // Check file size (max 25 MB)
                if (wavBlob.size > 25 * 1024 * 1024) {
                    showNotification('Audio-Datei ist zu gro√ü (max. 25 MB)', 'error');
                    updateStatus(currentTarget, 'idle', 'Zu gro√ü');
                    currentRecording = null;
                    currentTarget = null;
                    return;
                }

                // Create form data
                const formData = new FormData();
                const fileName = wavBlob.type === 'audio/wav' ? 'recording.wav' : 'recording.webm';
                formData.append('file', wavBlob, fileName);
                formData.append('model', WHISPER_MODEL);
                formData.append('language', 'de');
                formData.append('temperature', '1.0');
                formData.append('response_format', 'json');

                // Send to Whisper API
                const response = await fetch(WHISPER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const transcript = result.text || result.transcript || '';

                console.log('Whisper transcript:', transcript);
                console.log('Transcript length:', transcript.length);

                if (transcript) {
                    // Set transcript to voiceInput field - APPEND to existing content
                    const voiceInputElement = document.getElementById('voiceInput');
                    if (voiceInputElement) {
                        const newTranscript = transcript.trim();
                        
                        // Verify we're still processing for voiceInput (currentTarget should be 'voiceInput')
                        if (targetToProcess !== 'voiceInput' || !currentTarget) {
                            console.log('‚ö†Ô∏è Target changed during processing or invalid target. Expected:', targetToProcess, 'Current:', currentTarget);
                            // Still process, but log warning
                        }
                        
                        // Wenn bereits Text vorhanden ist, f√ºge einen Leerzeichen hinzu (APPEND Mode)
                        const currentValue = voiceInputElement.value.trim();
                        
                        // Check if this is a duplicate (same transcript as before)
                        if (currentValue && currentValue.endsWith(newTranscript)) {
                            console.log('‚ö†Ô∏è Duplicate transcript detected, skipping append');
                            updateStatus('voiceInput', 'idle', 'Duplikat erkannt');
                            showNotification('Transkription erkannt, aber Text scheint bereits vorhanden zu sein', 'error');
                            return;
                        }
                        
                        // Append new transcript
                        if (currentValue) {
                            voiceInputElement.value = currentValue + ' ' + newTranscript;
                        } else {
                            voiceInputElement.value = newTranscript;
                        }
                        
                        // Get the complete text for extraction
                        const completeText = voiceInputElement.value.trim();
                        
                        console.log('=== Whisper Transkription erfolgreich ===');
                        console.log('New transcript (length:', newTranscript.length, '):', newTranscript);
                        console.log('Previous text length:', currentValue.length);
                        console.log('Complete text after append (length:', completeText.length, ')');
                        console.log('First 300 chars:', completeText.substring(0, 300));
                        if (completeText.length > 300) {
                            console.log('Last 300 chars:', completeText.substring(completeText.length - 300));
                        }
                        
                        // Clear audio chunks after successful processing (should already be empty, but ensure it)
                        audioChunks = [];
                        
                        // Reset recording state
                        currentRecording = null;
                        // Keep currentTarget for now until extraction is complete
                        
                        // Trigger input event for validation
                        voiceInputElement.dispatchEvent(new Event('input'));
                        
                        // Automatically extract structured data using AI - use the complete text
                        console.log('=== Sending complete text to Mistral for extraction ===');
                        console.log('Text length:', completeText.length, 'characters');
                        updateStatus('voiceInput', 'processing', 'Extrahiere Felder...');
                        showNotification('Transkription erfolgreich! Extrahiere jetzt die Felder...', 'success');
                        await extractStructuredData(completeText);
                        
                        // Clear target after successful extraction
                        currentTarget = null;
                    }
                } else {
                    showNotification('Kein Text erkannt. Versuche es erneut.', 'error');
                    updateStatus('voiceInput', 'idle', 'Kein Text');
                    audioChunks = []; // Clear chunks on error too
                    currentRecording = null;
                    currentTarget = null;
                }

            } catch (error) {
                console.error('Error processing audio:', error);
                let errorMessage = error.message;
                
                // Check for CORS or network errors
                if (error.message.includes('Failed to fetch') || error.message.includes('ERR_NAME_NOT_RESOLVED') || error.message.includes('NetworkError')) {
                    errorMessage = 'Netzwerkfehler: Die API konnte nicht erreicht werden. ' +
                                  'M√∂gliche Ursachen: CORS-Problem, falsche URL, oder Netzwerkverbindung. ' +
                                  'Bitte pr√ºfe die API-URL und stelle sicher, dass die mittwald API CORS f√ºr diese Domain erlaubt.';
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMessage = 'Authentifizierungsfehler: Der API-Key ist ung√ºltig oder wurde nicht korrekt √ºbermittelt. Bitte pr√ºfe deinen API-Key.';
                } else if (error.message.includes('403') || error.message.includes('Forbidden')) {
                    errorMessage = 'Zugriff verweigert: Dein API-Key hat keine Berechtigung f√ºr diese Anfrage.';
                } else if (error.message.includes('429') || error.message.includes('Too Many Requests')) {
                    errorMessage = 'Rate Limit erreicht: Bitte warte einen Moment und versuche es erneut.';
                }
                
                showNotification('Fehler bei der Transkription: ' + errorMessage, 'error');
                updateStatus('voiceInput', 'idle', 'Fehler');
            } finally {
                // Always reset state after processing
                currentRecording = null;
                currentTarget = null;
                audioChunks = [];
                console.log('Audio processing finished, state cleared');
            }
        }

        async function convertToWav(audioBlob) {
            try {
                // Try to use AudioContext for conversion
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Convert to WAV
                const wav = audioBufferToWav(audioBuffer);
                return new Blob([wav], { type: 'audio/wav' });
            } catch (error) {
                console.warn('Error converting to WAV, trying to use original format:', error);
                // Fallback: Try to send as webm (if API supports it) or use audio/webm format
                // If webm doesn't work, we'll get an error from the API
                return audioBlob;
            }
        }

        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const numberOfChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const bytesPerSample = 2;
            const blockAlign = numberOfChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = length * blockAlign;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, bufferSize - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, 1, true); // audio format (PCM)
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bytesPerSample * 8, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // Convert audio data
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return arrayBuffer;
        }

        async function extractStructuredData(text) {
            const apiKey = getApiKey();
            if (!apiKey) {
                showNotification('API-Key fehlt', 'error');
                return;
            }

            if (!text || !text.trim()) {
                showNotification('Bitte gib zuerst einen Feature-Request ein', 'error');
                return;
            }

            try {
                // Reset structured fields before new extraction
                console.log('=== Resetting structured fields before extraction ===');
                const titleFieldReset = document.getElementById('title');
                const problemFieldReset = document.getElementById('problem');
                const solutionFieldReset = document.getElementById('solution');
                const additionalFieldReset = document.getElementById('additional');
                
                if (titleFieldReset) titleFieldReset.value = '';
                if (problemFieldReset) problemFieldReset.value = '';
                if (solutionFieldReset) solutionFieldReset.value = '';
                if (additionalFieldReset) additionalFieldReset.value = '';
                
                // Hide structured fields during extraction
                document.getElementById('structuredFields').style.display = 'none';
                
                updateStatus('voiceInput', 'processing', 'Extrahiere Felder mit AI...');
                showNotification('Extrahiere strukturierte Daten mit AI...', 'success');

                console.log('=== extractStructuredData called ===');
                console.log('Text received length:', text.length, 'characters');
                console.log('Full text:', text);
                console.log('Text preview (first 500 chars):', text.substring(0, 500));
                if (text.length > 500) {
                    console.log('Text preview (last 500 chars):', text.substring(text.length - 500));
                }

                // Security: Sanitize text input before sending to API
                const sanitizeInput = (input) => {
                    if (typeof input !== 'string') return '';
                    // Remove potential script injection attempts, null bytes, and limit length
                    const sanitized = input
                        .replace(/<script[^>]*>.*?<\/script>/gi, '')
                        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
                        .trim();
                    // Limit input size to prevent DoS (max 50KB)
                    return sanitized.substring(0, 50000);
                };
                
                const sanitizedText = sanitizeInput(text);
                if (sanitizedText.length === 0) {
                    showNotification('Eingabe ist leer oder enth√§lt ung√ºltige Zeichen', 'error');
                    return;
                }
                
                // User-Prompt: Nur der Feature-Request-Text, da der Systemprompt alle Anweisungen enth√§lt
                const prompt = `Analysiere den folgenden Feature-Request und extrahiere die strukturierten Daten gem√§√ü den Anweisungen im Systemprompt.

Feature-Request:
"""
${sanitizedText}
"""`;

                console.log('=== Sending to Mistral API ===');
                console.log('Prompt length:', prompt.length);
                console.log('Original text length:', text.length);
                console.log('Sanitized text length:', sanitizedText.length);
                console.log('Prompt preview (first 1000 chars):', prompt.substring(0, 1000));

                const requestBody = {
                    model: CHAT_MODEL,
                    messages: [
                        {
                            role: 'system',
                            content: FEATURE_REQUEST_SYSTEM_PROMPT
                        },
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 2000 // Genug Platz f√ºr vollst√§ndige Extraktion
                };

                console.log('Request body:', JSON.stringify(requestBody, null, 2).substring(0, 2000));

                const response = await fetch(CHAT_API_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const content = result.choices?.[0]?.message?.content || '';
                
                console.log('=== Mistral Response ===');
                console.log('Response content length:', content.length);
                console.log('Response content:', content);
                
                // Parse JSON response
                let structuredData;
                try {
                    // Try to extract JSON from markdown code blocks if present
                    let jsonString = content.trim();
                    
                    // Remove markdown code blocks if present
                    if (jsonString.includes('```')) {
                        const jsonMatch = jsonString.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                        if (jsonMatch && jsonMatch[1]) {
                            jsonString = jsonMatch[1];
                        }
                    }
                    
                    // If still not starting with {, try to find JSON object
                    if (!jsonString.startsWith('{')) {
                        const jsonMatch = jsonString.match(/(\{[\s\S]*\})/);
                        if (jsonMatch && jsonMatch[1]) {
                            jsonString = jsonMatch[1];
                        }
                    }
                    
                    // Remove control characters that are not allowed in JSON strings
                    // These characters cause "Bad control character" errors
                    jsonString = jsonString
                        // Remove control characters (except \n, \r, \t which need to be escaped)
                        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
                    
                    // Remove Markdown formatting from JSON string values
                    // This handles cases where AI returns **bold** or other markdown in JSON
                    // Process multiple times to handle nested or complex markdown
                    for (let i = 0; i < 3; i++) {
                        jsonString = jsonString
                            // Remove markdown bold (**text** -> text) - handle multiple asterisks
                            .replace(/\*\*+([^*]+?)\*\*+/g, '$1')
                            // Remove markdown italic (*text* -> text, but be careful with JSON structure)
                            .replace(/(?<!")\*([^*\n"']+?)\*(?!"|'|:)/g, '$1')
                            // Remove markdown code backticks
                            .replace(/`([^`]+)`/g, '$1')
                            // Remove markdown headers (# ## ###)
                            .replace(/^#{1,6}\s+/gm, '')
                            // Remove markdown list markers (- * +)
                            .replace(/^[\s]*[-*+]\s+/gm, '')
                            // Remove markdown links [text](url) -> text
                            .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
                    }
                    
                    // Fix unescaped newlines and other control characters in JSON string values
                    // Replace literal newlines inside string values with escaped version
                    jsonString = jsonString.replace(/(?<="[^"]*)\n(?=[^"]*")/g, '\\n');
                    jsonString = jsonString.replace(/(?<="[^"]*)\r(?=[^"]*")/g, '\\r');
                    jsonString = jsonString.replace(/(?<="[^"]*)\t(?=[^"]*")/g, '\\t');
                    
                    console.log('Parsing JSON string (before cleaning):', jsonString.substring(0, 500));
                    
                    // Try parsing, if it fails, try more aggressive cleaning
                    try {
                        structuredData = JSON.parse(jsonString);
                    } catch (parseError) {
                        console.warn('Parse failed with control character error, attempting to fix...');
                        // More aggressive cleaning: remove all problematic characters
                        jsonString = jsonString
                            // Remove all control characters
                            .replace(/[\x00-\x1F\x7F]/g, '')
                            // Fix any remaining unescaped quotes in strings
                            .replace(/(?<="[^"]*)"([^"]*)"([^"]*)"(?![^"]*":)/g, '$1\\"$2');
                        
                        console.log('Cleaned JSON, attempting to parse again...');
                        try {
                            structuredData = JSON.parse(jsonString);
                        } catch (secondError) {
                            console.error('Second parse attempt failed:', secondError);
                            throw new Error('AI konnte die Daten nicht korrekt strukturieren. Versuche es erneut oder formuliere deinen Request anders. Fehler: ' + secondError.message);
                        }
                    }
                    
                    // Security: Validate JSON structure and sanitize strings
                    if (typeof structuredData !== 'object' || structuredData === null) {
                        throw new Error('Invalid JSON structure: Expected object');
                    }
                    
                    // Validate and sanitize each field
                    const sanitizeString = (value) => {
                        if (typeof value !== 'string') return '';
                        // Remove potential script tags and null bytes
                        let sanitized = value.replace(/<script[^>]*>.*?<\/script>/gi, '')
                                    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
                                    .trim();
                        
                        // Remove Markdown formatting from string values
                        // Process multiple times to handle nested or complex markdown
                        for (let i = 0; i < 3; i++) {
                            sanitized = sanitized
                                // Remove markdown bold (**text** -> text) - handle multiple asterisks
                                .replace(/\*\*+([^*]+?)\*\*+/g, '$1')
                                // Remove markdown italic (*text* -> text, but be careful not to break JSON structure)
                                .replace(/(?<!")\*([^*\n"']+?)\*(?!"|'|:)/g, '$1')
                                // Remove markdown code backticks
                                .replace(/`([^`]+)`/g, '$1')
                                // Remove markdown headers (# ## ###)
                                .replace(/^#{1,6}\s+/gm, '')
                                // Remove markdown list markers at start of lines (- * +)
                                .replace(/^[\s]*[-*+]\s+/gm, '')
                                // Remove markdown links [text](url) -> text
                                .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
                        }
                        
                        // Normalize mittwald-specific terms (as per system prompt)
                        // Normalize "mittwald" variations
                        sanitized = sanitized.replace(/\b(Midwald|Mittwald|midwald|MIDWALD)\b/gi, 'mittwald');
                        // Normalize "mStudio" variations
                        sanitized = sanitized.replace(/\b(mstudio|MStudio|MSTUDIO|m-studio|M-Studio)\b/gi, 'mStudio');
                        // Normalize "Kundencenter" variations
                        sanitized = sanitized.replace(/\b(kundencenter|KundenCenter|KUNDENCENTER|kunden-center|Kunden-Center)\b/gi, 'Kundencenter');
                        // Fix common AI-Hosting naming errors
                        sanitized = sanitized.replace(/\bMidori-AI-Hosting\b/gi, 'mittwald AI-Hosting');
                        sanitized = sanitized.replace(/\bMidori\b/gi, 'mittwald');
                        // Fix "MidFist" -> should be checked if this is a real term or should be normalized
                        // For now, keeping it as is since it might be a specific term
                        
                        return sanitized;
                    };
                    
                    structuredData = {
                        title: sanitizeString(structuredData.title || ''),
                        problem: sanitizeString(structuredData.problem || ''),
                        solution: sanitizeString(structuredData.solution || ''),
                        additional: sanitizeString(structuredData.additional || '')
                    };
                    
                    // Validate required fields
                    if (!structuredData.title || structuredData.title.length === 0) {
                        throw new Error('Title field is required but empty');
                    }
                    if (!structuredData.problem || structuredData.problem.length === 0) {
                        throw new Error('Problem field is required but empty');
                    }
                    
                    console.log('Parsed and validated structured data:', structuredData);
                } catch (parseError) {
                    console.error('=== JSON Parse Error ===');
                    console.error('Parse error:', parseError);
                    console.error('Content received:', content);
                    console.error('Content length:', content.length);
                    throw new Error('AI konnte die Daten nicht korrekt strukturieren. Versuche es erneut oder formuliere deinen Request anders. Fehler: ' + parseError.message);
                }

                // Fill in the structured fields
                console.log('Filling structured fields with data:', structuredData);
                
                const titleField = document.getElementById('title');
                const problemField = document.getElementById('problem');
                const solutionField = document.getElementById('solution');
                const additionalField = document.getElementById('additional');
                
                // Security: Use textContent-like assignment for input values (already sanitized above)
                if (structuredData.title && titleField) {
                    // Input values are automatically escaped by the browser
                    titleField.value = structuredData.title;
                    console.log('Title set (length:', structuredData.title.length, ')');
                }
                if (structuredData.problem && problemField) {
                    problemField.value = structuredData.problem;
                    console.log('Problem set (length:', structuredData.problem.length, ')');
                }
                if (solutionField) {
                    solutionField.value = structuredData.solution || '';
                    console.log('Solution set (length:', (structuredData.solution || '').length, ')');
                }
                if (additionalField) {
                    additionalField.value = structuredData.additional || '';
                    console.log('Additional set (length:', (structuredData.additional || '').length, ')');
                }

                // Hide the main voice input field after successful extraction
                const voiceInputGroup = document.getElementById('voiceInputGroup');
                if (voiceInputGroup) {
                    voiceInputGroup.style.display = 'none';
                    console.log('Voice input group hidden');
                }

                // Show structured fields and submit actions
                const structuredFields = document.getElementById('structuredFields');
                const mainActions = document.getElementById('mainActions');
                const submitActions = document.getElementById('submitActions');
                
                if (structuredFields) {
                    structuredFields.style.display = 'block';
                    console.log('Structured fields displayed');
                }
                if (mainActions) {
                    mainActions.style.display = 'none';
                }
                if (submitActions) {
                    submitActions.style.display = 'flex';
                }

                // Reset status to idle with success message
                updateStatus('voiceInput', 'idle', 'Fertig');
                showNotification('Felder erfolgreich extrahiert! Du kannst sie jetzt bearbeiten oder direkt absenden.', 'success');

                // Scroll to structured fields for better UX
                document.getElementById('structuredFields').scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Validate form
                validateForm();

            } catch (error) {
                console.error('Error extracting structured data:', error);
                let errorMessage = error.message;
                
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMessage = 'Netzwerkfehler: Die AI konnte nicht erreicht werden. Pr√ºfe deine Verbindung und API-Key.';
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMessage = 'Authentifizierungsfehler: Der API-Key ist ung√ºltig.';
                }
                
                showNotification('Fehler bei der Extraktion: ' + errorMessage, 'error');
                updateStatus('voiceInput', 'idle', 'Fehler');
            }
        }

        function updateStatus(targetId, status, text) {
            let statusIndicator, statusText, recordBtn;
            
            if (targetId === 'voiceInput') {
                statusIndicator = document.getElementById('voiceStatus');
                statusText = document.getElementById('voiceStatusText');
                recordBtn = document.getElementById('recordVoice');
            } else {
                statusIndicator = document.getElementById(targetId + 'Status');
                statusText = document.getElementById(targetId + 'StatusText');
                recordBtn = document.getElementById('record' + targetId.charAt(0).toUpperCase() + targetId.slice(1));
            }

            if (statusIndicator) {
                statusIndicator.className = 'status-indicator ' + status;
            }
            if (statusText) {
                statusText.textContent = text;
            }
            if (recordBtn) {
                // Security: Escape HTML to prevent XSS
                const escapeHtml = (unsafe) => {
                    if (!unsafe) return '';
                    return String(unsafe)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                };
                
                if (status === 'recording') {
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '<span class="status-indicator recording"></span><span>‚èπÔ∏è Aufnahme stoppen</span>';
                } else if (status === 'processing') {
                    recordBtn.classList.remove('recording');
                    recordBtn.disabled = true;
                    // Use the actual status text from the parameter, but escape it for security
                    const buttonText = escapeHtml(text || 'Verarbeitung...');
                    recordBtn.innerHTML = `<span class="status-indicator processing"></span><span>‚è≥ ${buttonText}</span>`;
                } else {
                    recordBtn.classList.remove('recording');
                    recordBtn.disabled = false;
                    recordBtn.innerHTML = '<span class="status-indicator idle"></span><span>üé§ Sprachaufnahme</span>';
                }
            }
        }

        // Form submission
        document.getElementById('featureForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const issueData = buildIssueBody();
            const issueUrl = buildGitHubIssueUrl(issueData);
            window.open(issueUrl, '_blank');
        });

        // Copy to clipboard
        document.getElementById('copyBtn').addEventListener('click', function() {
            const issueData = buildIssueBody();
            const textToCopy = formatIssueForClipboard(issueData);
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showNotification('Issue-Text wurde in die Zwischenablage kopiert!', 'success');
            }).catch(err => {
                showNotification('Fehler beim Kopieren: ' + err, 'error');
            });
        });

        function buildIssueBody() {
            const title = document.getElementById('title').value.trim();
            const problem = document.getElementById('problem').value.trim();
            const solution = document.getElementById('solution').value.trim();
            const additional = document.getElementById('additional').value.trim();

            let body = '';
            
            if (problem) {
                body += '**Welches Problem m√∂chtest du l√∂sen? Wann tritt es auf?**\n\n';
                body += problem + '\n\n';
            }

            if (solution) {
                body += '**Welche L√∂sungsideen hast du?**\n\n';
                body += solution + '\n\n';
            }

            if (additional) {
                body += '**Hast du zus√§tzliche Informationen (wie z. B. Screenshots)?**\n\n';
                body += additional + '\n\n';
            }

            return {
                title: title,
                body: body
            };
        }

        function buildGitHubIssueUrl(issueData) {
            // Security: URLSearchParams automatically URL-encodes values, preventing injection
            const baseUrl = 'https://github.com/mittwald/feature-requests/issues/new';
            
            // Additional sanitization: ensure strings are valid
            const sanitizeForUrl = (str) => {
                if (typeof str !== 'string') return '';
                // Remove null bytes and control characters
                return str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '').trim();
            };
            
            const params = new URLSearchParams({
                title: sanitizeForUrl(issueData.title || ''),
                body: sanitizeForUrl(issueData.body || '')
            });
            return baseUrl + '?' + params.toString();
        }

        function formatIssueForClipboard(issueData) {
            // Security: Sanitize output for clipboard
            const sanitize = (str) => {
                if (typeof str !== 'string') return '';
                // Remove null bytes and control characters (except newlines and tabs)
                return str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '').trim();
            };
            return `Titel: ${sanitize(issueData.title || '')}\n\n${sanitize(issueData.body || '')}`;
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }

        // Form validation
        function validateForm() {
            const apiKey = getApiKey();
            const title = document.getElementById('title').value.trim();
            const problem = document.getElementById('problem').value.trim();
            const voiceInput = document.getElementById('voiceInput').value.trim();
            const submitBtn = document.getElementById('submitBtn');
            const copyBtn = document.getElementById('copyBtn');
            const extractBtn = document.getElementById('extractBtn');

            // Enable extract button if there's voice input
            if (apiKey && voiceInput) {
                extractBtn.disabled = false;
            } else {
                extractBtn.disabled = true;
            }

            // Enable submit buttons if structured fields are filled
            if (apiKey && title && problem) {
                if (submitBtn) submitBtn.disabled = false;
                if (copyBtn) copyBtn.disabled = false;
            } else {
                if (submitBtn) submitBtn.disabled = true;
                if (copyBtn) copyBtn.disabled = true;
            }
        }

        // Listen for input changes
        const voiceInputElement = document.getElementById('voiceInput');
        if (voiceInputElement) {
            voiceInputElement.addEventListener('input', validateForm);
        }
        
        document.getElementById('featureForm').addEventListener('input', validateForm);
        apiKeyInput.addEventListener('input', validateForm);

        // Listen to structured field changes
        ['title', 'problem', 'solution', 'additional'].forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.addEventListener('input', validateForm);
            }
        });

        // Form reset handler
        document.getElementById('featureForm').addEventListener('reset', function() {
            console.log('Form reset triggered');
            
            // Clear all audio chunks
            audioChunks = [];
            currentRecording = null;
            currentTarget = null;
            
            // Stop any recording
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // Reset structured fields
            document.getElementById('title').value = '';
            document.getElementById('problem').value = '';
            document.getElementById('solution').value = '';
            document.getElementById('additional').value = '';
            
            // Hide structured fields and show main input
            document.getElementById('structuredFields').style.display = 'none';
            document.getElementById('voiceInputGroup').style.display = 'block';
            document.getElementById('mainActions').style.display = 'flex';
            document.getElementById('submitActions').style.display = 'none';
            
            // Reset status
            updateStatus('voiceInput', 'idle', 'Bereit');
            
            // Reset validation
            setTimeout(validateForm, 100);
        });

        // Initialize button states
        validateForm();
    </script>
</body>
</html>
